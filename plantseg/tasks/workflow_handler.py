import json
from datetime import datetime
from enum import Enum
from inspect import signature
from pathlib import Path
from typing import Any, Callable
from uuid import UUID, uuid4

import yaml
from pydantic import BaseModel, Field

from plantseg.__version__ import __version__
from plantseg.core.image import PlantSegImage


class NodeType(str, Enum):
    NODE = "node"
    ROOT = "root"
    LEAF = "leaf"


class RunTimeInputSchema(BaseModel):
    description: str | None = None
    task: str | None = None
    required: bool = True
    default: Any = None
    is_input_file: bool = False


class Infos(BaseModel):
    """
    Information about the workflow.

    Attributes:
        description (str): An optional description of the workflow. This is only used for documentation purposes.
        creation_date (str): The date and time when the workflow was created. This is automatically generated.
        version (str): The version of plantseg used to create the workflow.
        inputs_schema (dict[str, RunTimeInputSchema]): A dictionary with the schema of the inputs of the workflow.
        instructions (str): Instructions on how to customize the workflow file.
    """

    description: str = "No description provided"
    creation_date: str = Field(
        default_factory=lambda: datetime.now().strftime("%Y-%m-%d-%H:%M:%S")
    )
    version: str = __version__
    inputs_schema: dict[str, RunTimeInputSchema] = Field(default_factory=dict)
    instructions: str = (
        "This configuration file was generated by PlantSeg and can be used to run a headless workflow. "
        "In order to run the workflow, you will need to customize this file with the correct paths and parameters. "
        "To read detailed instructions on how to do this, please visit the PlantSeg documentation (https://kreshuklab.github.io/plant-seg/)."
    )


class Task(BaseModel):
    func: str
    images_inputs: dict
    parameters: dict
    outputs: list[str]
    node_type: NodeType
    id: UUID = Field(default_factory=uuid4)
    skip: bool = False

    """
    A task is a single operation in the workflow. It is defined by:

    Attributes:
        func (str): The name of the function to be executed
        images_inputs (dict): A image input represent a Image object.
            The key is the name of the parameter in the function, and the value is the name of the image.
        parameters (dict): The kwargs parameters of the workflow function.
        outputs (list[str]): A list of the names of the output images.
        node_type (NodeType): The type of the node in the workflow (ROOT, LEAF, NODE)
        id (UUID): A unique identifier for the task.
        skip (bool): If True, the task will be skipped during the execution of the workflow.
            This is useful to remove a task that requires manual intervention (like a cropping task from the GUI).

    """


class DAG(BaseModel):
    infos: Infos = Field(default_factory=Infos)
    inputs: list[dict[str, Any]] = Field(default_factory=lambda: [{}])
    list_tasks: list[Task] = Field(default_factory=list)

    """
    This model represents the Directed Acyclic Graph (DAG) of the workflow.

    Attributes:
        infos (Infos): A dictionary with the information of the workflow.
        inputs (list[dict[str, Any]): A dictionary of the inputs of the workflow. For example path to the images and other runtime parameters.
        list_tasks (list[Task]): A list of the tasks in the workflow.

    """

    @property
    def list_inputs(self):
        return list(self.infos.inputs_schema.keys())


def prune_dag(dag: DAG) -> DAG:
    """
    Remove all the tasks that are not connected to the leaf nodes.
    """

    # Initialize the reachable set with the leaf nodes
    reachable = set()
    reachable_inputs = set()
    for task in dag.list_tasks:
        if task.node_type == NodeType.LEAF:
            for inp_key in task.images_inputs.values():
                reachable.add(task.id)
                reachable_inputs.add(inp_key)

    safety_counter = 0
    size_reachable = len(reachable)
    while True:
        # For each task check if the outputs is connected to the reachable set
        # if so, add the task to the reachable set
        for task in dag.list_tasks:
            for out_key in task.outputs:
                if out_key in reachable_inputs:
                    reachable.add(task.id)
                    for inp_key in task.images_inputs.values():
                        reachable_inputs.add(inp_key)

        safety_counter += 1
        if safety_counter > 1_000_000:
            raise ValueError("Infinite loop in the pruning of the DAG")

        # If the size of the reachable set did not change, we are done pruning
        if size_reachable == len(reachable):
            break
        size_reachable = len(reachable)

    new_dag = DAG()
    for task in dag.list_tasks:
        if task.id in reachable:
            new_dag.list_tasks.append(task)

    for input_key, text in dag.inputs[0].items():
        if input_key in reachable_inputs:
            new_dag.inputs[0][input_key] = text
            new_dag.infos.inputs_schema[input_key] = dag.infos.inputs_schema[input_key]

    return new_dag


class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class FuncsHandler(metaclass=SingletonMeta):
    """
    A singleton class to store the functions of the workflow.
    """

    def __init__(self):
        self._funcs = {}

    def register_func(self, func):
        self._funcs[func.__name__] = func

    def get_func(self, name):
        return self._funcs[name]

    def list_funcs(self):
        return list(self._funcs.keys())


class WorkflowHandler:
    """
    Container for a workflow. It stores the functions, the a list of tasks.
    """

    def __init__(self):
        self._funcs = FuncsHandler()
        self._dag = DAG()

    @property
    def dag(self) -> DAG:
        return self._dag

    @property
    def func_registry(self) -> FuncsHandler:
        return self._funcs

    def register_func(self, func):
        """
        Add a function to the workflow functions registry.
        """
        self._funcs.register_func(func)

    def add_task(
        self,
        func: Callable,
        images_inputs: dict,
        parameters: dict,
        outputs: list[str],
        node_type: NodeType,
    ):
        """
        Add a task to the workflow. This method is used by the task_tracker decorator and should not be called directly.

        Args:
            func (Callable): The function to be executed.
            images_inputs (dict): A dictionary of the image inputs. The key is the name of the parameter in the function,
                and the value is the unique_name of the image.
            parameters (dict): The kwargs parameters of the workflow function.
            outputs (list[str]): A list of the names of the output images.
            node_type (NodeType): The type of the node in the workflow (ROOT, LEAF, NODE)

        """
        assert func.__name__ in self._funcs.list_funcs(), (
            f"Function {func.__name__} not registered"
        )

        task = Task(
            func=func.__name__,
            images_inputs=images_inputs,
            parameters=parameters,
            outputs=outputs,
            node_type=node_type,
        )
        self._dag.list_tasks.append(task)

    def add_input(
        self,
        name: str,
        value: Any,
        value_schema: RunTimeInputSchema,
        func_name: str | None = None,
    ):
        def _unique_input(name, id: int = 0):
            new_name = f"{name}_{id}"
            if new_name not in self._dag.list_inputs:
                return new_name

            return _unique_input(name, id + 1)

        if name not in self._dag.list_inputs:
            unique_name = name
        else:
            unique_name = _unique_input(name)

        value_schema.task = func_name
        self._dag.infos.inputs_schema[unique_name] = value_schema

        self._dag.inputs[0][unique_name] = value
        return unique_name

    def clean_dag(self):
        self._dag = DAG()

    def prune_dag(self) -> DAG:
        """
        Remove all the tasks that are not connected to the leaf nodes.
        """
        return prune_dag(self._dag)

    def save_to_yaml(self, path: Path | str):
        clean_dag = self.prune_dag()
        dag_dict = json.loads(clean_dag.model_dump_json(exclude_none=True))

        if isinstance(path, str):
            path = Path(path)

        path.parent.mkdir(parents=True, exist_ok=True)

        with open(path, "w") as f:
            yaml.dump(dag_dict, f)

    def from_yaml(self, path: Path) -> "WorkflowHandler":
        with open(path, "r") as f:
            dag_dict = yaml.load(f, Loader=yaml.FullLoader)

        self._dag = DAG(**dag_dict)
        return self


workflow_handler = WorkflowHandler()


def task_tracker(
    func: Callable | None = None,
    is_root=False,
    is_leaf=False,
    list_inputs: dict[str, RunTimeInputSchema] | None = None,
):
    """
    Decorator to register a function as a task in the workflow.

    Args:
        func (Callable): The function that will be registered as a task.
        is_root (bool): If True, the function is a root node in the workflow (usually a import task).
        is_leaf (bool): If True, the function is a leaf node in the workflow (usually a writer task).
        list_inputs (dict[str, TaskUserInput]): A dictionary of the inputs of the function. The key is the name of the parameter
    """

    if is_root and is_leaf:
        raise ValueError("A node cannot be both root and leaf at the same time")

    if is_root:
        node_type = NodeType.ROOT
    elif is_leaf:
        node_type = NodeType.LEAF
    else:
        node_type = NodeType.NODE

    list_inputs = list_inputs or {}

    def _inner_decorator(func):
        workflow_handler.register_func(func)

        def wrapper(*args, **kwargs):
            assert len(args) == 0, (
                "Workflow functions should not have positional arguments"
            )
            func_signature = signature(func)
            parameters = {
                param: func_signature.parameters[param].default
                for param in func_signature.parameters
            }

            images_inputs = {}

            for name, arg in kwargs.items():
                if isinstance(arg, PlantSegImage):
                    images_inputs[name] = arg.unique_name
                    parameters.pop(name)

                elif name in list_inputs.keys():
                    value = list_inputs[name]
                    input_name = workflow_handler.add_input(
                        name, value=arg, value_schema=value, func_name=func.__name__
                    )
                    images_inputs[name] = input_name
                    parameters.pop(name)

                else:
                    # Replace the default value with the provided value
                    parameters[name] = arg

            # Execute the function
            out_image = func(*args, **kwargs)

            # Parse the output
            if out_image is None:
                list_outputs = []

            elif isinstance(out_image, PlantSegImage):
                list_outputs = [out_image.unique_name]

            elif isinstance(out_image, tuple) or isinstance(out_image, list):
                list_outputs = []
                for i, img in enumerate(out_image):
                    if not isinstance(img, PlantSegImage):
                        raise ValueError(
                            f"Output {i} is not an Image object, but {type(img)}"
                        )
                    list_outputs.append(img.unique_name)
            else:
                raise ValueError(
                    f"Output of a workflow function should be one of None, Image or tuple of Images. Got {type(out_image)}"
                )

            for name in list_outputs:
                if name in images_inputs.values():
                    raise ValueError(
                        f"Function {func.__name__} has an output image with the same name as an input image: {name}"
                    )

            # Add the task to the workflow
            workflow_handler.add_task(
                func=func,
                images_inputs=images_inputs,
                parameters=parameters,
                outputs=list_outputs,
                node_type=node_type,
            )
            return out_image

        wrapper.__plantseg_task__ = func.__name__
        return wrapper

    if func is None:
        return _inner_decorator

    return _inner_decorator(func)
